{
  "name": "node-sandbox",
  "version": "0.1.0",
  "description": "Advanced sandboxing library that allows communication between the sandbox and the parent process.",
  "keywords": [
    "sandbox",
    "library",
    "child_process"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/hflw/node-sandbox.git"
  },
  "author": {
    "name": "Will Riley",
    "email": "will@hflw.org",
    "url": "http://hflw.org/"
  },
  "dependencies": {
    "node-uuid": "1.3.3",
    "node-promise": "0.5.4",
    "underscore": "1.3.3"
  },
  "devDependencies": {
    "mocha": ">= 1.5.0"
  },
  "scripts": {
    "test": "cd lib/; mocha; cd ..;"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.6.0"
  },
  "readme": "node-sandbox\n============\n\nAbout\n-----\nnode-sandbox is a way of running untrusted code outside of your application's node process. You can interface with code running in the sandbox via RPC (or any library that works over the node `Stream` API).\n\nNote that at the moment, the only protection is that the code is run in a separate process, and that the process is prevented from loading certain C bindings used by core modules. In the future, there will be container plugins available to block off functionality to the process itself (eg FS access, ability to open sockets, etc.) Containment will be done on the OS-level to reduce the attack surface of the sandbox.\n\nNote that the method of containment used by the sandbox is far from bulletproof, and there is a very real possibility that malicious code could break out of the sandbox. In the future we will be working on improving it, but it will never be perfect.\n\nLicense\n-------\nThis library is Licensed under the Academic Free License version 2.1\n\nDocumentation\n=============\n\nUsing node-sandbox is pretty straightforward. The source code is fairly well documented, and there a good number of test cases, so if you have any questions, feel free to dive in!\n\nBasic Usage\n-----------\n\nNote: by default, the code being run won't have access to `require()` or anything. See \"Specifying Permissions\" for more info.\n\n```javascript\n//create a new sandbox instance w/ default options\nvar sb = new Sandbox(\"./path/to/code.js\");\n\n//expose a method for the sandbox to call\nsb.rpc.expose(\"someMethod\", function(arg){\n    console.log(arg);\n});\n\n//run the sandbox\nsb.run();\n\n//Wait for the sandbox to initialize.\n//We can't call methods until the sandbox is ready,\n//otherwise we'll get an error!\nsb.on(\"ready\", function(){\n    //call a method exposed by the sandbox\n    sb.rpc.call(\"someMethod\", [\"someArg\"]).then(function(result){\n        console.log(result);\n    });\n});\n```\n\nBasic Options\n-------------\n\nThere are some basic options you should know about for fringe cases.\n\nIf your node command isn't in your `PATH`, you need to specify it manually. By default, it just uses `node`.\n\nIf for some reason `Sandbox` isn't detecting the path to `shovel.js`, you can specify the path manually (it's in `node-sandbox/lib/shovel.js`)\n\n```javascript\nvar sb = new Sandbox(\"path/to/code.js\", {\n    \n    //the node command used to spawn the child process\n    node_command: \"node\"\n\n    //the path to the shovel (what bootstraps the child process)\n    shovel: path.join(__dirname, \"shovel.js\"),\n\n});\n```\n\nOther options are discussed in the relevant sections!\n\nSpecifying Permissions\n----------------------\n\nSpecifying permissions is somewhat complicated. In node, there's a function called `process.binding()` that's used by node's built-in modules to get the relevant C bindings for things like I/O, crypto, and others. `process.binding()` works like `require()` does; you pass a module as an argument, and it fetches the relevant C binding.\n\nnode-sandbox's permissions system will block off loading of the C bindings. To allow loading of them, we need to pass a `permissions` option to it, specifying which C bindings are allowed to be loaded.\n\nThe following are the permissions specified by default, and are needed for the sandbox to run.\n\n```javascript\nvar sb = new Sandbox(\"./path/to/code.js\", {\n    permissions: [\"tty_wrap\", \"pipe_wrap\"]\n});\n```\n\nIf you want to allow use of specific modules (eg `fs` or `crypto`), look at their file in [node's `lib/` directory](https://github.com/joyent/node/tree/master/lib), and see what bindings they load by searching for `process.binding`. Then pass any modules needed through `permissions` array.\n\nNote that if you want access to `require()`, you'll need to pass the following to permissions:\n\n```javascript\nvar sb = new Sandbox(\"./path/to/code.js\", {\n    permissions: [\"tty_wrap\", \"pipe_wrap\"] //TODO: figure these out\n});\n```\n\nExposing RPC Methods\n--------------------\nnode-sandbox comes with a stock RPC library that uses JSON-RPC in a bi-directional way, so that both ends can expose methods for the other to call. We can access it through `Sandbox.rpc`.\n\nExposing methods in the main process is easy:\n\n```javascript\nvar sb = new Sandbox(/* options etc */);\nsb.run();\n\n//we can expose individual methods, eg:\nsb.rpc.expose(\"addOne\", function(arg){\n    return arg+1;\n});\n\n//we can create namespaces by including a '.'\nsb.rpc.expose(\"myNamespace.someMethod\", function(){\n    return true;\n});\n\n//we can unexpose methods like this!\nsb.rpc.unexpose(\"myNamespace.someMethod\");\n\n//alternatively, we can opt to expose an entire object.\n//This deletes anything that was already exposed previously.\nsb.rpc.exposeObject({\n    addOne: function(arg){\n        return arg+1;\n    },\n    myNamespace: {\n        someMethod: function(){ return true; }\n    }\n});\n\n//unexposing still works the same way when\n//using exposeObject\nsb.rpc.unexpose(\"myNamespace.someMethod\");\n```\n\nIf you need to work with asynchronous libraries in the methods you expose, you can return a `Promise` object instead. You can use any `Promise` library you like, but I use [Kris Zyp's node-promise](https://github.com/kriszyp/node-promise).\n\n```javascript\nsb.rpc.expose(\"asyncMethod\", function(){\n    var p = new Promise();\n\n    setTimeout(function(){\n        p.callback(\"Success!\");\n        //or\n        p.errback(\"Failure!\");\n    }, 2000);\n\n    return p;\n});\n```\n\nExposing methods within the sandbox works the same way, except we use the global `rpc` variable instead of `Sandbox.rpc`. Inside the sandbox, `Promise` is accessible globally for convenience.\n\n```javascript\nrpc.expose(\"myMethod\", function(){\n    var p = new Promise();\n    // etc. etc.\n    return p;\n});\n```\n\nCalling RPC Methods\n-------------------\n\nTo call methods, you can use `Sandbox.rpc.call`, or `Sandbox.rpc.notify`. Both methods will call the remote method, but `call` will give you a return value, while `notify` won't (see the JSON-RPC docs if this is confusing).\n\nIt's important to note that you can't call methods until after `Sandbox` has emitted a `ready` event! See the \"Basic Usage\" code snippet for an example.\n\n`call` will return a `Promise` object to give you the result asynchronously. See the docs for [Kris Zyp's node-promise](https://github.com/kriszyp/node-promise) for all available methods.\n\n```javascript\n//this will call the method like so: myMethod(1, 2, 3);\nsb.rpc.call(\"myMethod\", [1, 2, 3]).then(\n    function(result){\n        console.log(\"Success! \"+result);\n    },\n    function(error){\n        console.log(\"We got an error: \"+error.message);\n    }\n);\n\n//if we pass call() an object as arguments, it'll call the method like this: myMethod(myObj);\nvar myObj = {foo: \"bar\"};\nsb.rpc.call(\"myMethod\", myObj);\n\n\n//here's an example using notify(). It's arguments are identical to call()\nsb.rpc.notify(\"myMethod\", [1, 2, 3]); //no returned value\n```\n\nAgain, the API is identical from within the sandbox. Just use the `rpc` global variable instead of `Sandbox.rpc`\n\n```javascript\nrpc.call(\"myMethod\", [1, 2, 3]);\n```\n\nRPC Call Timeouts\n-----------------\n\nSometimes, we might want to specify a timeout for method calls, just in case. We can do this one of two ways.\n\nThe first is to use the `Promise` api:\n\n```javascript\nvar p = rpc.call(\"myMethod\", [1, 2, 3]);\np.timeout(10000); //timeout after 10 seconds\np.then(/* ... */);\n```\n\nThe second is to add an additional `call_timeout` option, eg:\n\n```javascript\nvar sb = new Sandbox(\"path/to/code.js\", {\n    call_timeout: 10000 //10 seconds\n});\n```\n\nBy default, `call_timeout` is `-1`, which disables timeouts to method calls. The value specified in `call_timeout` will also be applied to the `rpc` class inside the sandbox.\n\nDetecting when the sandbox exits\n--------------------------------\n\nWe can detect when the sandbox exits using the `exit` event.\n\n```javascript\nsb.on(\"exit\", function(){\n    console.log(\"the sandbox ended!\");\n});\n```\n\nLockup detection & killing the sandbox\n--------------------------------------\nnode-sandbox has built in lockup detection, so if a stray `while()` loop locks up the sandbox, we can react to it.\n\nTo kill the sandbox, we can use `Sandbox.kill()`.\n\n```javascript\nvar sb = new Sandbox(\"path/to/code.js\", {\n    permissions: [/*...*/],\n    \n    //Here are some relevant options for lockup detection.\n    //All time is specified in milliseconds.\n    //Set any of these values to -1 to disable them.\n\n    //how long we should wait for a reply\n    //before emitting a 'lockup' event. (default: 10 seconds)\n    lockup_timeout: 10000,\n    \n    //how long we should wait after killing the process\n    //to kill -9 it. (default: 10 seconds)\n    kill_with_fire_timeout: 10000,\n    \n    //how frequently we should check the sandbox (default: 10 seconds)\n    ping_interval: 10000,\n    \n    //how long we should wait before assuming\n    //the sandbox failed to start (locked up immediately)\n    //(default: 10 seconds)\n    startup_timeout: 10000,\n\n});\n\nsb.run();\n\nsb.on(\"lockup\", function(){\n    //restart the sandbox\n    sb.kill();\n    sb.run();\n});\n```\n\nDetecting output on STDERR\n--------------------------\n\nIf something ever goes wrong within the sandbox, by default it doesn't get printed to the main process' `STDOUT`. Instead, you need to listen on the `stderr` event and do it yourself, eg:\n\n```javascript\nsb.on(\"stderr\", function(text){\n    console.err(text);\n});\n```\n\nYou can also pass this on to any logging library you use.\n\nPinging the Sandbox\n-------------------\n\nIf you want to ping the sandbox to figure out latency, you can use `Sandbox.ping()`, which returns a `Promise` object.\n\n```javascript\nsb.ping().then(function(time){\n    console.log(\"Sandbox latency: \"+time);\n}, function(err){\n    console.log(\"Failed to ping sandbox!\");\n});\n```\nPlugins\n-------\n\nnode-sandbox has a full featured plugin system, and a lot of it's features are provided by built-in plugins. Built-in plugins can be found in `lib/plugins/`, and include the following:\n\n* `_base`: not meant to be loaded, but provides base functionality to other plugins\n* `rpc`: provides JSON-RPC functionality (exposed through `Sandbox.rpc`) over the `Stream` between the parent and child processes exposed by `Sandbox`.\n* `lockup_detection`: provides lockup detection functionality, including the `on(\"lockup\")` event. Relies on `rpc`.\n* `wrapper`: wraps `process.binding` so that any unauthorized modules aren't allowed to be loaded.\n\nEventually I'd like to include a plugin that can set up a secure container for the child process using OS features (eg SELinux). If you know a lot about this sort of thing and would like to contribute, please let me know!\n\nPlugins can be specified using the `plugins` option:\n\n```javascript\nvar sb = new Sandbox(\"path/to/file.js\", {\n    plugins: [\n        //Note: these are the default plugins that are loaded. If you want to load an extra plugin, you should include these built-in ones too!\n        \"rpc\", \"lockup_detection\", \"wrapper\"\n    ]\n});\n```\n\nNote that plugin hooks are executed in the order that they're provided in the array, so make sure \"wrapper\" goes last, otherwise a plugin might not have access to the resources it needs to initiate itself!\n\nSome plugins in the future may take additional arguments, but all the built-in ones at the time of writing read from the main arguments passed to the sandbox (for the sake of ease-of-use). Here's an example on how to pass custom arguments to a plugin:\n\n```javascript\nvar sb = new Sandbox(\"path/to/file.js\", {\n    plugins: [\n        {\n            name: \"my_plugin\",\n            options: {foo: \"bar\"}\n        },\n        \"some_other_plugin\"\n    ]\n});\n```\n\nTo load an external plugin, simply pass a path to the directory containing all the plugin's files (`manifest.js`, etc.) instead of a plugin name. It can either be an absolute path, or relative to the `lib/PluginManager.js` file:\n\n```javascript\nvar sb = new Sandbox(\"path/to/file.js\", {\n    plugins: [\n        {\n            name: \"/path/to/my_plugin\",\n            options: {foo: \"bar\"}\n        },\n        //OR\n        \"/path/to/my_plugin\"\n    ]\n});\n```\n\nWriting Custom Plugins\n----------------------\n\nThe plugin system lets you hook into the sandbox and add any functionality you want. Things you can do include:\n\n* Extend the sandbox by adding custom options and methods, and pretty much override/wrap any function/variable you want\n* Run code during certain events in the parent process (eg when the child process exits, when the process writes to stderr, etc.)\n* Run code inside the child process (eg when the process spawns, after the code is loaded, after the code is executed, etc.)\n* Pass extra arguments to the child process via `startData`\n\nUsing this, you can write your own RPC plugin, container plugin, or anything else you need. I strongly suggest looking in the `lib/plugins` directory for examples, especially at the `_base` plugin, which documents when each hook is called.\n\nPlugins consist of three files:\n\n* `plugin_name/manifest.js`: a manifest file that provides information about the plugin.\n* `plugin_name/ParentHooks.js`: a class that provides hooks for the parent process and allows you to hook into each `Sandbox` instance.\n* `plugin_name/ShovelHooks.js`: a class that provides hooks for `shovel.js`, which is what's run to create our child process.\n\n`ParentHooks` and `ShovelHooks` should both extend the respective classes in the `_base` plugin. `manifest.js` can simply be copied to your plugin's directory.\n\nThe `PluginManager` class loads the plugins, and does some basic dependency/conflict checks. Below is the `manifest.js` file from the `_base` plugin:\n\n```javascript\nmodule.exports = {\n    name: \"_base\", //the name of the parent directory our plugin is in\n    provides: [], //features that it provides. This is flexible, so it can be something like \"container\" or \"rpc\".\n    conflicts: [], //features or specific plugins this plugin conflicts with.\n    depends: [] //features or specific plugins that this plugin requires to run.\n}\n```\n\nTo put this into practice, lets say we want to write a replacement for the RPC plugin. If we put `\"rpc\"` in the `provides` array, the plugin manager will throw an error if any other plugins that provide the `\"rpc\"` functionality are loaded. This way two plugins won't fight over access to `Sandbox.rpc`.\n\nIf we don't provide RPC functionality, but for one reason or the other we conflict with the RPC module (maybe our plugin wants to use the `Stream` between parent and child processes exclusively), we can put it in the `conflicts` array instead.\n\nIf our plugin depended on the RPC class in order to pass data between the parent and child processes, we could put `\"rpc\"` in the `depends` array. Note that any plugin that provides the `\"rpc\"` functionality would satisfy this requirement. For this reason, it's strongly suggested that any module that provides a specified functionality should have an identical base API (extra functions are allowed to be implemented).\n\nTo implement subclasses of `ParentHooks` and `ShovelHooks`, take a look inside of the respective class definitions in the `_base` class. Everything is well documented in there, and will explain how to access things through member variables, and which methods get called when.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hflw/node-sandbox/issues"
  },
  "_id": "node-sandbox@0.1.0",
  "dist": {
    "shasum": "33dd486103c57cbad6f3d74e9bf034c88b191e77"
  },
  "_from": "node-sandbox@",
  "_resolved": "https://registry.npmjs.org/node-sandbox/-/node-sandbox-0.1.0.tgz"
}
